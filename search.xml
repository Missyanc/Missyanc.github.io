<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Linux-2018/9/20]]></title>
    <url>%2F2018%2F09%2F20%2FLinux-2018-9-20%2F</url>
    <content type="text"><![CDATA[2018/9/20Ch. Screen Programingrefresh 代价是很大的，一般是覆盖 大概过程是 先打印 “helloworld_” 注意此时光标位置 再吧光标移回去 “_helloworld” 再打印 “ ” 覆盖 下一个版本 + 人机交互 给移动加上边界 usleep $10^-6s$ interval timer（itimer）：间隔计时器，时钟编程why sleep can stop? And when a process is sleeping ,can we use other process?? 时间到这是一个信号：SIGALRM，时钟信号？？ alarm(5) pause() 挂起一个进程 系统里面会为你提供三个间隔计时器 Real ： 这是真实的时间，过去一秒就是一秒 Virtual ： 这貌似是对应用户代码的时间 Prof ： 用户代码和内核代码加起来的时间为 Prof 怎么使用呢，需要设置两个时间： it_value ： 开始时间 双精度 s,us，确保能够取到不同精度的时间 it_interval ： 间隔时间 在 Linux 中有一个结构体 itimerval 存放 it_value 与 it_interval 而 it_value 与 it_interval 也是一个结构体 那究竟这个咋就厉害了？ ITIMER_REAL 相当于一个软中断 如何实现一个弹球 关闭规则模式： crmode() noecho() 现在能够一维的移动球 但是我们希望这个球能够在二维中移动 Ch.Process如何查看系统上的进程 123456789psps -lsort &amp; // 可以在后台执行nice -n 5 sort &amp; // 加上指定的优先数renice n PID // 给某 PID 的进程加上 n 的优先数 ps -e // 查看所有的进程状态，包括后台和其他用户ps aux ps -l 得到的进程属性： PPID : Parent PID PRI : 优先级，值越小，优先级越高，一般不好调整，但是可以通过优先数调整，只能增加优先级，唯有超级用户可以提高优先级 SZ : 进程占用内存大小 TTY：终端 WCHAN：状态 进程的生与死 单体无性繁殖 如何在一个进程里面执行一个别的进程？？ execlp(CMD,ARG!1…); execvp(CMD,); Done 咋就不见了呢 exec 相当于换脑，把下面的换了 所以现在而言直接这样执行是不能这样执行的！ 怎么办？？ fork ./a.out &amp; ps -l 所以现在有了办法，不能直接换脑，所以我们可以生成一个子进程给他换脑，fork fork() 会完全复制一个父进程，包括代码状态和数据，状态就是此时代码运行到哪的状态，这个也不会变 父进程和子进程 fork 后是完全独立的，相互竞争计算机的资源 3 个 fork 是 8 个进程 但是问题来了，我们怎么知道谁是子进程谁是父进程？？ 通过 fork 的返回值，是一个进程号，fork 失败返回 -1 问题来了，怎么实现父子进程的协调呢？？？比如要等子进程执行完父进程再继续？ wait()，有一个地址参数 问题来了，杀了子进程他也回来了，买菜成功？？？这可不行 用返回值实现， status 是 16 bit的数 0 - 7 ： exit value (0 - 255) 8 : core dump 9 - 16 : signal Linux 在终端敲命令其实是 shell 的一个 fork 1 号进程为 init 进程，是所有进程的父进程，如果我们杀了 cook （父）进程，那么 shopping 进程则会吧 init 进程作为父进程，此时被杀了父进程的 shopping 进程也叫孤儿进程 Zombie 进程：僵尸进程(defunct)，没有调用 wait() 进程回收 SIGCHLD 为忽略僵尸进程]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[R-first-chapter]]></title>
    <url>%2F2018%2F09%2F19%2FR-first-chapter%2F</url>
    <content type="text"><![CDATA[第一章 认识数据分析与 R 语言数据分析数据分析是指用适当的统计分析方法对收集来的大量数据进行分析，提取有用信息和形成结论而对数据加以详细研究和概括总结的过程 数据分析的原则： 数据分析是为了验证假设的问题，必须提供必要的数据验证。即构建完分析模型后，需要利用测试数据验证模型正确性。 数据分析是为了发现更多问题，并找到深层次原因 不能为了做数据分析而分析。必须有明确的问题或目 数据分析的步骤 探索性数据分析 找到数据中隐含信息；探索规律性的可能的形式（探索方向和方式）；通常需要数据清洗和整合 模型选定分析 通过定量分析，提出一类或几类可能的模型；再进一步分析，确定一类适合的模型 推断分析 使用数理统计方法， 对所确定模型或估计的可靠程度和精度做出推断 传统数据分析过程 明确目标 搜集数据 加工整理 缺失值处理、数据分组、数据取值转换…… 选择方法 解释结果 “大数据”分析过程 数据采集 预处理 数据清洗等。 统计和分析 可以满足大多数常见的分析需求 数据挖掘 与统计分析不同，数据挖掘一般没有什么预先设定好的主题 R 语言简介 R是用于统计分析和绘图的编程语言和软件环境 R是 GNU 包，因此是自由软件。源码使用 C、Fortran 和 R 进行编写 R语言历史 R语言是S语言的一种方言 1976年，贝尔实验室的John Chambers 开发S语言，以替代昂贵的 SPSS 和 SAS 工具 1992年，新西兰奥克兰大学两位统计学教授 Ross Ihaka 和 Robert Gentleman 开发，Chambers 也是开发成员 R 的优势 统计学家发明的：全面的统计研究平台，提供格式各样的数据分析技术 开源：可以自己修改（包和函数）；免费 交互式数据分析 why？？？ 可以从多中数据源导入数据，存在 bug 新算法（新的包）会迅速在R中实现 轻量级，安装文件小（不超过100M） 兼容不同的OS R的劣势 统计学家发明的：语法和一般程序设计语言差别很大，学习曲线陡峭，对于程序员来说“奇怪的”术语 开源导致 package 的质量、版本兼容性等问题 内存管理、速度与效率问题 不能直接利用R开发应用程序 R 的获取和安装 R 可以在 CRAN（Comprehensive RArchive Network）http://cran.r-project.org 上免费下载。Linux、Mac OS X 和 Windows 都有相应编译好的二进制版本 R的使用 R是一种区分大小写的解释型语言 eg.shell R中的多数功能是由程序内置函数和用户自编函数提供的，一次交互式会话期间的所有数据对象都被保存在内存中。一些基本函数是默认直接可用的，而其他高级函数则包含于按需加载的程序包中 什么是解释性语言、脚本语言。一行一行的解释 R语句由函数和赋值构成。R使用 &lt;-，而不是传统的 = 作为赋值符号。注释由符号 # 开头 x = x + 1 与 x &lt;- x + 1，前者不科学 Windows 从开始菜单中启动R。Mac需要双击应用程序文件夹中的R图标。Linux 在终端命令提示符下敲入R并回车 一个例子： 1234567# Listing 1.1 - A Sample R sessionage &lt;- c(1,3,5,2,11,9,3,9,12,3)weight&lt;-c(4.4,5.3,7.2,5.2,8.5,7.3,6.0,10.4,10.2,6.1)mean(weight) #均值sd(weight) #标准差cor(age,weight) #相关度plot(age,weight) #画图 R 获取帮助 R的内置帮助系统提供了当前已安装包中所有函数的细节、参考文献以及使用示例 help.start() 打开帮助文档首页 help(&quot;foo&quot;)或?foo 查看函数 foo 的帮助（引号可以省略） help.search(&quot;foo&quot;) 或 ??foo 以 foo为关键词搜索本地帮助文档 example(&quot;foo&quot;) 函数 foo 的使用示例（引号可以省略） RSiteSearch(&quot;foo&quot;) 以 foo 为关键词搜索在线文档和邮件列表存档 apropos(&quot;foo&quot;, mode=&quot;function&quot;) 列出名称中含有 foo 的所有可用函数 data() 列出当前已加载包中所含的所有可用示例数据集 vignette() 列出当前已安装包中所有可用的 vignette 文档(一般是 PDF 文章) vignette(&quot;foo&quot;) 为主题 foo 显示指定的 vignette 文档 工作空间（workspace） 工作空间就是当前R的工作环境，它储存着所有用户定义的对象（向量、矩阵、函数、数据框、列表。可以将当前工作空间保存到一个镜像中，并在下次启动R时自动载入它 当前的工作**目录（working directory）是 R 用来读取文件和保存结果的默认目录 输入和输出 输入：函数 source(&quot;filename&quot;) 可在当前会话中执行一个脚本 文本输出：函数 sink(&quot;filename&quot;) 将输出重定向到文件filename中 图形输出 包（package） 包是R函数、数据、预编译代码以一种定义完善的格式组成的集合。计算机上存储包的目录称为库（library）。 函数 library() 则可以显示库中有哪些包 目前有 2500 多个包可从 http://cran.rproject.org/web/packages下载。这些包提供了横跨各种领域的新功能，包括分析地理数据、处理蛋白质质谱，甚至是心理测验分析的功能 包的安装 执行 install.packages() 将显示一个 CRAN 镜像站点的列表，选择其中一个镜像站点之后，将看到所有可用包的列表，选择其中的一个包即可进行下载和安装 例如，可以用可以使用命令 install.packages(&quot;gclus&quot;) 来下载和安装 gclus 包（注意有引号）。 包的载入 要在R会话中使用包，需要用 library() 命令载入这个包 例如，要使用 gclus 包，执行命令 library(gclus) 即可（注意没有引号）]]></content>
      <categories>
        <category>R 语言</category>
      </categories>
      <tags>
        <tag>R 语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[49. Group Anagrams]]></title>
    <url>%2F2018%2F09%2F18%2FAnagrams%2F</url>
    <content type="text"><![CDATA[49. Group Anagrams问题描述：Given an array of strings, group anagrams together. Example：1234567Input: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;],Output:[ [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;], [&quot;nat&quot;,&quot;tan&quot;], [&quot;bat&quot;]] Note： All inputs will be in lowercase. The order of your output does not matter. 问题分析：分析：Two strings are anagrams if and only if their sorted strings are equal. 用 Map 实现：维护一个 map ans : {String -&gt; List} ，每一个 Key 为一个排序好的 string，并且每一个 value 为从最初输入的字符串 Lis 里排序了且 equal to Key 的 List Java代码实现：1234567891011121314public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs)&#123; if (strs.length == 0) return new ArrayList(); Map&lt;String,List&gt; ans = new HashMap&lt;String, List&gt;(); for (String s: strs)&#123; char[] chars = s.toCharArray(); Arrays.sort(chars); // 把他们排序 String key = String.valueOf(chars); if (!ans.containsKey(key)) ans.put(key,new ArrayList()); ans.get(key).add(s); &#125; return new ArrayList(ans.values());//返回所有的 List&lt;String&gt; &#125; Ouch！Accepted！]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[50.pow(x,n)]]></title>
    <url>%2F2018%2F09%2F17%2F50-pow-xn%2F</url>
    <content type="text"><![CDATA[50.Pow(x,n)问题描述：Implement pow(x, n), which calculates x raised to the power n(x^n) Example 1:12Input: 2.00000, 10Output: 1024.00000 Example 2:12Input: 2.10000, 3Output: 9.26100 Example 3:123Input: 2.00000, -2Output: 0.25000Explanation: 2^-2 = 1/2^2 = 1/4 = 0.25 Note: -100.0 &lt; x &lt; 100.0 n is a 32-bit signed integer, within the range [−2^31, 2^31 − 1] 分析我的第一想法是用迭代，用一个变量 result 保存结果然后: 12345if (n &gt; 0) for (int i =0 ;i &lt; n;i++) result = result * x;else if (n &lt; 0) for (int i =0 ;i &lt; -n;i++) result = result * (1/x);else return result = 1; ok,看完发现没问题，submit！ Ouch！超时了，完蛋，明显不行。 换一个思路：递归 1234567double res = 0;if (n == 0) return 1;if (n &lt; 0)&#123; n = -n; x = 1 / x; &#125;return (n % 2 == 0) ? pow(x*x,n/2) : x * pow(x*x,n/2); ok，没问题，submit！ Ouch！说当输入是 (2,Integer.MIN_VALUE) 时返回了一个 Infinity ,查了查发现这是说无限。 emmmm 开始去查资料找原因，发现是代码第4行，-n 超过了值，java 中整型的数 最大为 2^31 - 1 而 -Integer.MIN_VALUE 恰好比 2^31 - 1 多 1，所以越界 于是终极 Accepted代码为： 12345678910public static double pow(double x,int n)&#123; double res = 0; if (n &lt; 0)&#123; n = -(n + 1); x = 1 / x; res = (n % 2 == 0) ? pow(x*x,n/2) : x * pow(x*x,n/2); return res * x; &#125;else return (n % 2 == 0) ? pow(x*x,n/2) : x * pow(x*x,n/2); &#125; ————————————-分界线：知识补充———————————— 问题解决，发现是自己的基础知识不够引起的，于是开始补习： Java 中的整型Java 中有四种整型数据，分别是 byte, short, int, long。 它们的区别表现在单个数据所占的字节数以及取值范围的不同。具体见下表: 类型 字节数 取值范围 byte 1 -128~127 short 2 -32768~32767 int 4 -2147483648~2147483647 long 8 -9223372036854775808~9223372036854775807 值得一提的是，在 Java中，没有无符号位的整型数据，即所有的整型数据都是可以表示正数和负数的 Java 中的进制和其他编程语言一样，Java 中常用的进制位二进制、八进制、十进制、十六进制。其实八进制也不是太经常使用 二进制二进制的表示只包含 0 和 1 两种符号。在 Java 中，二进制的表示格式为： 1int x = 0b10101010 即在二进制数前面加了 0b 八进制八进制的表示包含 0、1、2、3、4、5、6、7 这八种符号。在 Java 中，八进制的表示格式为： 1int x = 01010101010 即在八进制数前面加了 0. 显然这种表示方法很容易弄混，一定得小心对待 十进制十进制即为日常数字使用的进制，它的表示包含 0、1、2、3、4、5、6、7、8、9 这十种符号。十进制的表示不需要特别的格式，和平时使用的数字表示一样 十六进制十六进制的表示包含 0、1、2、3、4、5、6、7、8、9、a、b、c、d、e、f 这十六中符号。在 Java 中，十六进制的表示格式为： 1int x = 0x10101010 即在十六进制数前加 0x.在任何进制表示的数字后面加上符号 L 即表示该数字为 long 型。此外， 从 Java7 以后，表示二进制、八进制、十进制、十六进制数的时候，可以在数中添加下划线以方便阅读。经过尝试，发现在数的最前面和最后面添加下划线是会报错的，即下划线只能添加在数的中间，不能加在数字的两端 1234int a = 0b1010_1010int b = 01010_1010int c = 1010_1010int d = 0x1010_1010]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件需求分析与设计]]></title>
    <url>%2F2018%2F09%2F16%2F%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[一个项目的里程碑 第一个里程碑：产品确定，合同的签订（就像是软件的生） 软件的设计模型 第二个里程碑：软件的上线 最后一个里程碑：软件下架，不再使用（软件的死） 本门课讲的就是从软件合同签订到软件的设计模型确定这一个过程 一个问题：软件的架构设计，这样的人才很少。在美国一个不成文的规定是：只有从事软件行业8年以上的人才有资格成为软件架构师 第一章 软件进程软件开发的本质，通过人类的干预是解决不了的 复杂性 一致性 可变性 不可见性 软件开发的偶然性因素，通过人工的干预是可以改善的 利益干系人 软件工程 模型/建模 利益干系人：Stakeholder（股票持有人） 客户 老板 开发人员 投资人 股东 用户 竞争对手 PM 家人 政府 软件过程 顺序 成果物 分配给具体的人 鉴定标准 软件开发模式（软件过程） 瀑布模型 敏捷开发 增量迭代模型 RVP 软件开发方法 面向对象方法 面向功能方法（结构化） 面向数据方法 面向过程方法 … 面向对象的第一个原则： OCP原则，开发封闭原则：代码是可增加的，不可修改的 也就是面向接口编程 面向对象和结构化方法的区别 分解方法 功能 对象 代码层次 开发方法 一个栗子：五子棋程序 结构化的分解： 开始 黑方先行 绘制棋盘 判断输赢 轮到白子 绘制棋盘 判断输赢 返回步骤2 输出结果 面向对象分解： main 棋子 移动 棋盘 绘制 规则系统：提取出来做一个配置文件 判断输赢 那么问题来了，我想做一个围棋系统，面向对象只需要换一个配置文件就行 那么问题又来了，我想做一个国际象棋，对于面向对象，把棋子抽象成基类，五子棋和国际象棋继承就好啦，那就是棋子的配置图片不一样就行。 —————————————-分界线，上课第一周—————————————]]></content>
      <categories>
        <category>软件课程</category>
      </categories>
      <tags>
        <tag>课程</tag>
        <tag>需求分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于我的Hexo配置记录]]></title>
    <url>%2F2018%2F09%2F13%2F%E5%85%B3%E4%BA%8E%E6%88%91%E7%9A%84Hexo%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[关于我的 Hexo 配置记录配置背景动画 设置 canvas_nest 无效 如果 next 主题版本在 5.1.1 以上的话，直接在themes/next目录下，将配置文件_config.yml中找到canvas_nest: false，改为canvas_nest: true即可，但是博主配置了无效 - 配置背景图片]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>技术学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 如何从云服务器转到 GitHub Pages+Windows 本地部署]]></title>
    <url>%2F2018%2F09%2F12%2F%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[关于 Hexo 如何从云服务器转到 GitHub Pages+Windows 本地部署后来考虑到我的云服务器的优惠就是两年，博主现在大一，等以后大学毕业了阿里云的云服务器也不会再是9.9元/月了，而是一千多大洋，所以到时候买不买还是一个问题，于是在花了很多天捣鼓好了云服务器的配置之后毅然决然的抛弃了他转而用 GitHub Pages 部署我的 Hexo博客，毕竟想一直用下去嘛~ 先总体说一下我的大概的步骤吧 首先当然是搭建好本地环境 完成本地 Hexo 的安装和测试 把云服务器上的关于 Hexo 博客的文件夹整个拷贝到本地并且替代本地的 Hexo 文件夹 部署 Windows 本地的 Hexo 博客到 GitHub 上 这样做下来弄好之后，新的博客一点没变，所有配置依旧玩好无缺，所有博文也是丝毫不差 搭建本地环境1. 摘要，这儿是默认大家都有了 GitHub 账号，要是没有请去注册一个再来 需要安装好 Git Bash 需要安装 Node.js 需要安装 Hexo 2. 安装 Git Bash 去官网下载 Git 客户端：下载地址 安装 Git 客户端：Windows 用户直接 Next 就可以了。Mac 和 Linxu 系统的用户可通过命令方式安装，这里不详细介绍了 3. 安装 Node.js Node.js 官网 4. 创建 GitHub 仓库 登录进入 GitHub 进入创建仓库页面，这个没什么好说的 填写创建仓库信息： 仓库名称必须是：你的用户名.github.io，比如博主 GitHub 的名字为 Missyanc，仓库名称就为：Missyanc.github.io，以后再解释为什么 填写好相关信息，点击 Create repository(创建仓库) 按钮。 5. 配置 SSH 打开 Git Bash 终端 设置 user name 和 email： 12$ git config --global user.name &quot;你的GitHub用户名&quot;$ git config --global user.email &quot;你的GitHub注册邮箱&quot; 一般情况下是不需要密码的，所以，接下来直接回车就好 此时，在用户文件夹下就会有一个新的文件夹.ssh，里面有刚刚创建的 ssh 密钥文件 id_rsa 和 id_rsa.pub 注：id_rsa 文件是私钥，要妥善保管，id_rsa.pub 是公钥文件。 添加公钥到 github：点击用户头像，然后点击显示的 Settings(设置) 选项 在用户设置栏，点击 SSH and GPG keys 选项，然后点击 New SSH key(新建 SSH) 按钮 Titel 可以随便取一个，将 id_rsa.pub 中的内容复制到 Key 文本框中，然后点击 Add SSH key(添加 SSH) 按钮 可以测试一下 SSH ： 1$ ssh -T git@github.com 以上搭建本地环境完成 本地 Hexo 的安装和测试1.新建博客文件夹：这里就取名为 blog1mkdir blog 2.安装 Hexo 先进入到 blog 目录 1cd blog 安装 Hexo 1npm install hexo-cli -g 初始话 Hexo 1hexo init 启动测试 Hexo 是否安装初始化成功 12hexo ghexo s 启动之后，打开浏览器，在地址栏输入：http://localhost:4000，你会看到 Hexo 的示例页面 Hexo 把云服务器上的关于 Hexo 博客的文件夹整个拷贝到本地把云服务器上原本的 Hexo 博客文件夹拷贝下来 注：博主用的与云服务器终端连接的工具为 Xshell，传输文件的为 Xftp 找到云服务器的文件夹，然后传输下来，如下图： 等到该文件夹下载完毕把该文件夹下所有的文件拷贝替代原本本地博客 blog 下的所有文件 现在在 Git Bash 上输入： 12# 清除缓存hexo clean 然后再如上启动 Hexo，并且打开浏览器，在地址栏输入：http://localhost:4000看是否为你的云服务器上的 Hexo 12hexo ghexo s 部署 Windows 本地的 Hexo 博客到 GitHub 上 编辑配置文件，关联远程仓库。在编辑器中打开 Hexo 配置文件_config.yml，找到下面内容： 1234# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: 添加 github 仓库信息： 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:Missyanc/Missyanc.github.io.git #github仓库地址 branch: master # github分支 把其中repo字段的值替换成你的github pages提交代码的 git 地址 别告诉我你不知道你的 github pages 的 git 提交地址。就是你刚刚创建那个github pages仓库的地址 注意：type、repo、branch 的前面有两个空格，后面的: 后面有一个空格 安装 git 插件 1npm install hexo-deployer-git --save 如果没有安装 git 插件，会有错误提示，安装后重新部署就可以了 部署 1hexo d 如果没有意外，部署就成功了，可以打开 https://你的用户名.github.io 查看 ps.&emsp;hexo 命令缩写 hexo g：hexo generate hexo c：hexo clean hexo s：hexo server hexo d：hexo deploy 耶，大功告成！接下来就是搞我的 Hexo 配置啦]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>技术学习</tag>
        <tag>云服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F09%2F12%2Fhello-world%2F</url>
    <content type="text"><![CDATA[标准开头Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[阿里云服务器添加安全组规则]]></title>
    <url>%2F2018%2F09%2F11%2F%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%B7%BB%E5%8A%A0%E5%AE%89%E5%85%A8%E7%BB%84%E8%A7%84%E5%88%99%2F</url>
    <content type="text"><![CDATA[阿里云服务器添加安全组规则 先登录你的阿里云并且进入到管理控制台 找到安全组，点击进入，具体操作如下图： 进入安全组之后，点击配置规则，具体操作如下图： 开始配置规则，如下图所示： 点击确定，添加安全组规则完成]]></content>
      <categories>
        <category>云服务器</category>
      </categories>
      <tags>
        <tag>技术学习</tag>
        <tag>云服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里云服务器配置Hexo最详细教程]]></title>
    <url>%2F2018%2F09%2F11%2F%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AEHexo%E6%9C%80%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[记录自己的整个 Hexo 安装 写在前面，本人用的是阿里的云服务器与 Hexo 搭建的个人博客，可以与 git 网站关联，代码可以实时上传在 git 上，云服务器是基于 Linux 系统的，如果只是单纯的想部署到云服务器上可以忽略以下的 git 相关部分，以后再试着整个全部部署在 git bash 上 这整个过程我花了好几天摸索搞好，现在写下来记录 做这个博客本人的初衷是记录下和家人与所爱的人发生的事，以及自己学习的历程 一、环境搭建 第一步我们先安装 Node.js ，我是选择的下载压缩包然后解压然后安装 在官网下载压缩包：1wget https://nodejs.org/dist/v8.1.2/node-v8.1.2.tar.gz 解压缩：1tar -zxvf node-v8.1.2.tar.gz 安装 Node.js：1nvm install stable 第二步就是安装 Hexo 1nvm install stable &emsp;&emsp;以上的步骤的目录的可以自选，但是最好在 root 目录下 二、创建我们的完整的博客目录 确保你的 Linux 云服务器上装好了 git，如果没有请装上 git ，git安装及相关操作教程请看廖雪峰的 git 教程 第一步是选择好目录，挑好了你的建博客的地址。我们先要建 git 本地仓库的目录并且初始化 git 本地仓库 1mkdir git_blog 在该目录下初始化 git 本地仓库： 1git init 在这个 git 本地仓库的目录下建好 Hexo 博客目录并且初始化 1mkdir Hexo 1hexo init &emsp;&emsp;此时 root/git_blog 目录的文件目录结构如下： 三、测试我们的 Hexo 看能否正常打开 默认的端口号为4000，所以普通的系统我们只需要输入 http://localhost:4000 就好。 但是我们的是阿里云服务器，部署的是 Linux 系统，所以我们的测试用以下命令测试： 1curl http://localhost:4000 OK，输入上面的命令得到一堆东西，到这你的都应该和我一样没问题，当然目前用的是默认的 Hexo 主题 landscape 于是博主就开心的去了自己的 Windows 系统的 Chrome 浏览器下输入了博主自己的阿里云服务器私有ip + :4000（ip:4000）地址，结果无法访问 于是又开始了辛苦（想哭）的找问题过程 结果就是我解决啦，也明白了ip和端口号的关系！问题在于我的阿里云服务器安全组没有给4000这个端口放心，关于阿里云服务器怎么添加端口安全组请看这：阿里云服务器添加安全组配置 ps.&emsp;博主连接阿里云服务器终端是用的 Xshell 工具]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>技术学习</tag>
        <tag>云服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我爱的是言草右小姐]]></title>
    <url>%2F2018%2F09%2F11%2F%E6%88%91%E7%88%B1%E7%9A%84%E8%A8%80%E8%8D%89%E5%8F%B3%E5%B0%8F%E5%A7%90%2F</url>
    <content type="text"><![CDATA[我爱的是言草右小姐，Missyanc2018/9/12 言草右小姐送给我一块漂亮的手表，这是别人送我第一块表，言草右小姐说她想用这块手表换取我的时间，让我能和她一直玩。]]></content>
      <categories>
        <category>言小姐</category>
      </categories>
      <tags>
        <tag>yanc</tag>
        <tag>myLove</tag>
      </tags>
  </entry>
</search>
